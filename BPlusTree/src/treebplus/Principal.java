/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package treebplus;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author César
 */
public class Principal extends javax.swing.JFrame {

    /**
     * Creates new form Principal
     */
    public Principal() {
        initComponents();
    }


    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabelColheita = new javax.swing.JLabel();
        jTextFieldColheita = new javax.swing.JTextField();
        jButtonExecutar = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTableDados = new javax.swing.JTable();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        jLabelColheita.setText("Digite o ano da Colheita:");

        jTextFieldColheita.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jTextFieldColheitaKeyPressed(evt);
            }
            public void keyTyped(java.awt.event.KeyEvent evt) {
                jTextFieldColheitaKeyTyped(evt);
            }
        });

        jButtonExecutar.setText("Executar");
        jButtonExecutar.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                jButtonExecutarMousePressed(evt);
            }
        });

        jTableDados.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "VCod", "Produtor", "Cepa", "Colheita", "País"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane1.setViewportView(jTableDados);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(20, 20, 20)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(10, 10, 10)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 327, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabelColheita)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextFieldColheita, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(jButtonExecutar)))
                .addContainerGap(43, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabelColheita, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jTextFieldColheita, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButtonExecutar))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 241, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(40, Short.MAX_VALUE))
        );

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonExecutarMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jButtonExecutarMousePressed
        if(jTextFieldColheita.getText().equals("")){
            JOptionPane.showMessageDialog(this, "O campo de busca não pode ser vazio", "Erro", JOptionPane.ERROR_MESSAGE);
            jTextFieldColheita.requestFocus();
        }else{
            DefaultTableModel model = (DefaultTableModel) jTableDados.getModel();
            model.setNumRows(0);
            boolean indice = true;
            int key_inp = Integer.parseInt(jTextFieldColheita.getText());
            String noX,ind,noY;
            int key,ridX,ridY;
            int linhaX=0,linhaY=1;
            while(indice==true){
                try {
                    //aqui ele lê na memória o nó corrente
                    String lineX = Files.readAllLines(Paths.get("E:\\Indice.txt")).get(linhaX);
                    String lineY = Files.readAllLines(Paths.get("E:\\Indice.txt")).get(linhaY);
                    //aqui ele dá um split na string de cima separando os dados para consulta
                    String [] partsX = lineX.split(",");
                    key = Integer.parseInt(partsX[0]);
                    noX = partsX[1];
                    ridX = Integer.parseInt(partsX[2]);
                    ind = partsX[3];
                    String [] partsY = lineY.split(",");
                    noY = partsY[1];
                    ridY = Integer.parseInt(partsY[2]);
                    //aqui ele verifica se é Indice o nó corrente
                    if(ind.equals("EInd")){
                        //se ele for menor ele pega o nó do rid que eu quero, e na próxima iteração
                        //ele lê o filho "certo"
                        if(noX.equals("L")){
                            if(key_inp<key){
                                linhaX = ridX-1;
                                linhaY = ridX;
                            }
                        }
                        //se ele for maior, a lógica é análoga a de cima
                        if(noY.equals("R")){
                            if(key_inp>=key){
                                linhaX = ridY-1;
                                linhaY = ridY;
                            }
                        }
                    //caso o nó corrente não seja mais indice ele busca o desejado no nó filho
                    }else{
                        List<String> lines = Files.readAllLines(Paths.get("E:\\Indice.txt"), Charset.defaultCharset());
                        int noOfLines = lines.size();
                        int keyD,cont=0;
                        //aqui ele percorre no nó folha a partir de onde o indice deixar no nó folha
                        while(linhaY<=noOfLines){
                            String lineD = Files.readAllLines(Paths.get("E:\\Indice.txt")).get(linhaY-1);
                            String [] partsD = lineD.split(",");
                            keyD = Integer.parseInt(partsD[0]);
                            if(key_inp==keyD){
                                cont++;
                            }
                            linhaY++;
                        }
                        //a lógica do cont é que se ele achar algum nó folha com a chave desejada ele incrementa
                        //caso o cont for zero, logo não tem chave na árvore com a buscada
                        if(cont==0){
                            JOptionPane.showMessageDialog(this, "Ano de Colheita não encontrado nos dados", "Erro", JOptionPane.ERROR_MESSAGE);
                        }else{
                            try {
                                Object vec[] = new Object[5];
                                Scanner scanner = new Scanner(new FileReader("E:\\Dados.txt"))
                                        .useDelimiter("\\||\\n");
                                while (scanner.hasNext()) {
                                    String vcod = scanner.next();
                                    String produtor = scanner.next();
                                    String cepa = scanner.next();
                                    String ano = scanner.next();
                                    String pais = scanner.next();
                                    if(Integer.parseInt(ano) == Integer.parseInt(jTextFieldColheita.getText())){
                                        vec[0] = vcod;
                                        vec[1] = produtor;
                                        vec[2] = cepa;
                                        vec[3] = ano;
                                        vec[4] = pais;
                                        model.addRow(vec);
                                    }
                                }   
                            } catch (FileNotFoundException ex) {
                                Logger.getLogger(Principal.class.getName()).log(Level.SEVERE, null, ex);
                            }
                        }
                        indice = false;
                    }
                } catch (IOException ex) {
                    Logger.getLogger(Principal.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }
    }//GEN-LAST:event_jButtonExecutarMousePressed

    private void jTextFieldColheitaKeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextFieldColheitaKeyTyped
        //Evento para JTextField aceitar apenas números.
        String caracteres="0987654321";
        if(!caracteres.contains(evt.getKeyChar()+"")){
            evt.consume();
        }
    }//GEN-LAST:event_jTextFieldColheitaKeyTyped

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        File fD = new File("E:\\Dados.txt");
        fD.delete();
        File fI = new File("E:\\Indice.txt");
        fI.delete();
    }//GEN-LAST:event_formWindowClosing

    private void jTextFieldColheitaKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextFieldColheitaKeyPressed
        if(evt.getKeyCode()==10){
            if(jTextFieldColheita.getText().equals("")){
            JOptionPane.showMessageDialog(this, "O campo de busca não pode ser vazio", "Erro", JOptionPane.ERROR_MESSAGE);
            jTextFieldColheita.requestFocus();
        }else{
            DefaultTableModel model = (DefaultTableModel) jTableDados.getModel();
            model.setNumRows(0);
            boolean indice = true;
            int key_inp = Integer.parseInt(jTextFieldColheita.getText());
            String noX,ind,noY;
            int key,ridX,ridY;
            int linhaX=0,linhaY=1;
            while(indice==true){
                try {
                    //aqui ele lê na memória o nó corrente
                    String lineX = Files.readAllLines(Paths.get("E:\\Indice.txt")).get(linhaX);
                    String lineY = Files.readAllLines(Paths.get("E:\\Indice.txt")).get(linhaY);
                    //aqui ele dá um split na string de cima separando os dados para consulta
                    String [] partsX = lineX.split(",");
                    key = Integer.parseInt(partsX[0]);
                    noX = partsX[1];
                    ridX = Integer.parseInt(partsX[2]);
                    ind = partsX[3];
                    String [] partsY = lineY.split(",");
                    noY = partsY[1];
                    ridY = Integer.parseInt(partsY[2]);
                    //aqui ele verifica se é Indice o nó corrente
                    if(ind.equals("EInd")){
                        //se ele for menor ele pega o nó do rid que eu quero, e na próxima iteração
                        //ele lê o filho "certo"
                        if(noX.equals("L")){
                            if(key_inp<key){
                                linhaX = ridX-1;
                                linhaY = ridX;
                            }
                        }
                        //se ele for maior, a lógica é análoga a de cima
                        if(noY.equals("R")){
                            if(key_inp>=key){
                                linhaX = ridY-1;
                                linhaY = ridY;
                            }
                        }
                    //caso o nó corrente não seja mais indice ele busca o desejado no nó filho
                    }else{
                        List<String> lines = Files.readAllLines(Paths.get("E:\\Indice.txt"), Charset.defaultCharset());
                        int noOfLines = lines.size();
                        int keyD,cont=0;
                        //aqui ele percorre no nó folha a partir de onde o indice deixar no nó folha
                        while(linhaY<=noOfLines){
                            String lineD = Files.readAllLines(Paths.get("E:\\Indice.txt")).get(linhaY-1);
                            String [] partsD = lineD.split(",");
                            keyD = Integer.parseInt(partsD[0]);
                            if(key_inp==keyD){
                                cont++;
                            }
                            linhaY++;
                        }
                        //a lógica do cont é que se ele achar algum nó folha com a chave desejada ele incrementa
                        //caso o cont for zero, logo não tem chave na árvore com a buscada
                        if(cont==0){
                            JOptionPane.showMessageDialog(this, "Ano de Colheita não encontrado nos dados", "Erro", JOptionPane.ERROR_MESSAGE);
                        }else{
                            try {
                                Object vec[] = new Object[5];
                                Scanner scanner = new Scanner(new FileReader("E:\\Dados.txt"))
                                        .useDelimiter("\\||\\n");
                                while (scanner.hasNext()) {
                                    String vcod = scanner.next();
                                    String produtor = scanner.next();
                                    String cepa = scanner.next();
                                    String ano = scanner.next();
                                    String pais = scanner.next();
                                    if(Integer.parseInt(ano) == Integer.parseInt(jTextFieldColheita.getText())){
                                        vec[0] = vcod;
                                        vec[1] = produtor;
                                        vec[2] = cepa;
                                        vec[3] = ano;
                                        vec[4] = pais;
                                        model.addRow(vec);
                                    }
                                }   
                            } catch (FileNotFoundException ex) {
                                Logger.getLogger(Principal.class.getName()).log(Level.SEVERE, null, ex);
                            }
                        }
                        indice = false;
                    }
                } catch (IOException ex) {
                    Logger.getLogger(Principal.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }
        }
    }//GEN-LAST:event_jTextFieldColheitaKeyPressed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonExecutar;
    private javax.swing.JLabel jLabelColheita;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable jTableDados;
    private javax.swing.JTextField jTextFieldColheita;
    // End of variables declaration//GEN-END:variables
}
